

import pandas as pd
import numpy as np
from scipy import stats
import warnings

# A comprehensive list of continuous distributions from scipy.stats to test against.
# This list is chosen to cover a wide variety of shapes (normal, skewed, heavy-tailed, etc.).
# Some distributions are commented out due to their constraints (e.g., beta requires data in [0, 1])
# or because they are less common for general-purpose fitting.
CANDIDATE_DISTRIBUTIONS = [
    stats.norm,         # Normal
    stats.lognorm,      # Log-Normal
    stats.expon,        # Exponential
    stats.gamma,        # Gamma
    stats.weibull_min,  # Weibull Minimum
    stats.t,            # Student's t-distribution (robust to outliers)
    stats.genextreme,   # Generalized Extreme Value (very flexible)
    stats.johnsonsu,    # Johnson SU (highly flexible, four parameters)
    stats.gumbel_r,     # Gumbel (Right-skewed)
    stats.powerlaw,     # Powerlaw
    stats.chi2,         # Chi-squared
]

def is_significantly_zero_inflated(series: pd.Series, zero_threshold: float = 0.01, verbose: bool = False) -> bool:
    """
    Performs a rigorous, library-driven test to determine if a continuous time series is zero-inflated.

    The method compares two competing hypotheses using the Akaike Information Criterion (AIC):
    1.  H0 (Single-Process Model): The data (including zeros) is generated by a single continuous distribution.
    2.  H1 (Hurdle/Two-Process Model): The data is generated by a two-stage process:
        a) A Bernoulli trial decides if a value is zero or positive.
        b) If positive, the value is drawn from a continuous distribution fitted only to the positive data.

    To ensure robustness, this function tests a wide range of candidate distributions for both hypotheses
    and selects the one with the best fit (lowest AIC) for each hypothesis before comparing them.

    Args:
        series (pd.Series): The time series data to test.
        zero_threshold (float): A minimum proportion of zeros required to run the full test.
                                If the proportion is below this, the series is considered not zero-inflated.
                                Defaults to 0.01 (1%).
        verbose (bool): If True, prints the detailed results of the model comparison.

    Returns:
        bool: True if the Hurdle model (H1) provides a better fit (lower AIC),
              indicating significant zero-inflation. False otherwise.
    """
    series_clean = series.dropna()
    if series_clean.empty:
        return False

    # --- Step 1: Basic Checks ---
    n_total = len(series_clean)
    n_zeros = (series_clean == 0).sum()
    zero_prop = n_zeros / n_total

    if zero_prop < zero_threshold:
        if verbose:
            print(f"Zero proportion ({zero_prop:.2%}) is below threshold ({zero_threshold:.2%}). Not considered zero-inflated.")
        return False

    positives = series_clean[series_clean > 0]
    n_positives = len(positives)
    if n_positives == 0:
        if verbose:
            print("Series contains only zeros. Considered zero-inflated.")
        return True # A series of only zeros is trivially zero-inflated.

    best_aic_h0 = np.inf
    best_dist_h0 = None
    best_aic_h1 = np.inf
    best_dist_h1 = None

    # --- Step 2: Iterate through candidate distributions ---
    with warnings.catch_warnings():
        warnings.simplefilter("ignore") # Suppress warnings from fitting

        for dist in CANDIDATE_DISTRIBUTIONS:
            # --- H0: Fit a single distribution to all data ---
            try:
                # Fit distribution to all data, forcing location to 0 to prevent "cheating"
                params_h0 = dist.fit(series_clean, floc=0)

                # --- SYSTEMATICALLY CORRECT LIKELIHOOD CALCULATION FOR H0 ---
                # For positive values, use the log of the PDF (density)
                log_likelihood_positives_h0 = np.sum(dist.logpdf(positives, *params_h0))

                # For zero values, use the log of the CDF (a true probability)
                # This represents the probability of the distribution generating a value in a small interval near zero.
                epsilon = np.finfo(float).eps # A very small number
                log_likelihood_zeros_h0 = n_zeros * np.log(dist.cdf(epsilon, *params_h0))

                # Combine the likelihoods
                log_likelihood_h0 = log_likelihood_positives_h0 + log_likelihood_zeros_h0

                # A valid model must produce a finite log-likelihood.
                if not np.isfinite(log_likelihood_h0):
                    continue

                k_h0 = len(params_h0)
                aic_h0 = 2 * k_h0 - 2 * log_likelihood_h0

                if aic_h0 < best_aic_h0:
                    best_aic_h0 = aic_h0
                    best_dist_h0 = dist.name
            except Exception:
                continue # Some distributions might fail to fit

            # --- H1: Fit a hurdle model (Zero-inflated) ---
            try:
                # Fit distribution only to positive data
                params_h1 = dist.fit(positives)
                # a) Log-Likelihood of the continuous part (for positive values)
                log_likelihood_continuous = np.sum(dist.logpdf(positives, *params_h1))
                # b) Log-Likelihood of the Bernoulli part (zero vs. positive)
                log_likelihood_bernoulli = n_zeros * np.log(zero_prop) + n_positives * np.log(1 - zero_prop)

                log_likelihood_h1 = log_likelihood_bernoulli + log_likelihood_continuous
                
                # Number of parameters for H1 is (params for continuous dist) + 1 (for Bernoulli zero_prop)
                k_h1 = len(params_h1) + 1
                aic_h1 = 2 * k_h1 - 2 * log_likelihood_h1

                if aic_h1 < best_aic_h1:
                    best_aic_h1 = aic_h1
                    best_dist_h1 = dist.name
            except Exception:
                continue

    if verbose:
        print("\n--- Zero-Inflation Test Results ---")
        print(f"Best Single-Process Model (H0): '{best_dist_h0}' with AIC = {best_aic_h0:.4f}")
        print(f"Best Hurdle Model (H1)        : '{best_dist_h1}' with AIC = {best_aic_h1:.4f}")
        if best_aic_h1 < best_aic_h0:
            print(f"\nConclusion: The Hurdle model is a better fit (AIC difference: {best_aic_h0 - best_aic_h1:.4f}).")
            print("-> The series IS likely zero-inflated.")
        else:
            print(f"\nConclusion: The Single-Process model is a better (or equal) fit.")
            print("-> The series is NOT likely zero-inflated.")
        print("-------------------------------------\n")

    # The series is zero-inflated if the AIC of the hurdle model is lower
    return best_aic_h1 < best_aic_h0
